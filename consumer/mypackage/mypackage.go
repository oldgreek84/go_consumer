package mypackage

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
)

type TopicsSt struct {
	Topics map[string]interface{} `json:"topics"`
}

func GetTopics() []string {

	bytes_data, err := ioutil.ReadFile("mypackage/topics.json")
	if err != nil {
		fmt.Printf("Error: %v", err.Error())
	}

  var top map[string]map[string]interface{}
  json.Unmarshal([]byte(bytes_data), &top)

  res := make([]string, 0, len(top["topics"]))

	for k, v := range top["topics"] {
		fmt.Printf("\nkey %v => %v", k, v)
    res = append(res, k)

	}

	return res

}

type my_result map[string]map[string]interface{}
type mytype []map[string]string
type my_map map[string]interface{}

func GetTopicsTest() string {
	var data my_result
	file, _ := ioutil.ReadFile("mypackage/topics.json")
	json.Unmarshal(file, &data)
	fmt.Println(data)

	// var my_result mytype
	topics, err := os.Open("mypackage/topics.json")
	if err != nil {
		fmt.Print(err.Error())
	}
	byteValue, _ := ioutil.ReadAll(topics)

	var my_result_data my_map
	json.Unmarshal([]byte(byteValue), &my_result_data)
	fmt.Printf("\nResult: %v\n\n", my_result_data)

	var other_data AutoGenerated
	json.Unmarshal([]byte(byteValue), &other_data)

	v := reflect.ValueOf(other_data.Topics)
	res := make([]interface{}, v.NumField())
	for i := 0; i < v.NumField(); i++ {
		tem_field := v.Field(i).Interface()
		fmt.Println(reflect.TypeOf(tem_field))
		fmt.Println(v.Type().Field(i).Name)
		fmt.Println(tem_field)
		res[i] = v.Type().Field(i).Name

	}
	fmt.Println(res)

	return ""
}

func Walk(v interface{}) {
	switch v := v.(type) {
	case []interface{}:
		for i, v := range v {
			fmt.Println("index:", i)
			Walk(v)
		}
	case map[interface{}]interface{}:
		for k, v := range v {
			fmt.Println("key:", k)
			Walk(v)
		}
	default:
		fmt.Println(v)
	}
}
